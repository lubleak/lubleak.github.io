---
title: 识别字符型验证码
date: 2022-01-04 10:55:03
tags: python，验证码识别
---
# 前情概要
在学习自动化测试的时候，每次调试代码的时候，都需要手动输入验证，十分的麻烦，然后就想着整个识别验证码。本文的验证码识别只针对简单的字符型验证码，此文借鉴的是这位大佬的文章，[点这](https://www.cnblogs.com/beer/p/5672678.html)。
# 免责声明
本篇文章只是用于学习交流使用
# 流程
整体流程大概分为八个步骤，在运行以下代码前需要导入以下包
``` 代码
import base64
import os
import requests
from PIL import Image
from pathlib import Path
from libsvm.python.libsvm.svm import *
from libsvm.python.libsvm.svmutil import *
``` 
## 1、下载图片
下载图片这个环节中，每个人找的验证码和链接都不相同，我这边的请求接口返回的是使用base64加密过的结果，需要先获取到返回的结果，然后解密之后下载。
``` 代码
def down_img(url,number,savepath):
    for x in range(number):
        res = requests.get(url, stream=True)
        burl = res.text
        burl = eval(burl)
        img_base = burl.get("result")[22:]
        img_data = base64.b64decode(img_base)
        imgpath = savepath + str(x) + '.jpg'
        imgpath = Path(imgpath).as_posix()
        with open(imgpath, 'wb') as f:
            f.write(img_data)
            f.flush()
            f.close()
        bimg = get_bin_table(imgpath)
```
在下载图片时可能会存在像下面的报错，需要在代码中添加以下代码可以解决。
![错误提示](/image/dowimg.png)
``` 代码
global false, null, true
false = null = true = ''
``` 
ps：我在这偷懒，直接在下载图片的时候进行处理图片`
## 2、处理图片（降噪、二值化图片）
``` 代码
def get_bin_table(path, threshold=50):
    """
    获取灰度转二值的映射table
    :param threshold:趋向0为黑，反之为白
    :return:
    """
    image = Image.open(path)
    imgl = image.convert('L')
    table = []
    for i in range(256):
        if i < threshold:
            table.append(0)
        else:
            table.append(1)

    out = imgl.point(table, '1')
    bmppath = os.path.splitext(path)[0] + '.bmp'
    bmppath = Path(bmppath).as_posix()
    out.save(bmppath)
    os.remove(path)
```
这边存在一个坑，在二值化图片之后，保存的图片最好是保存为bmp格式，之前保存为jpg格式的文件，图片依旧存在灰点，是因为保存jpg格式存在失真的问题
##  3、切割图片
切割图片需要根据自己的验证码进行划分，找出验证码中每个字符生成位置的规律，根据规律进行切割
``` 代码
def get_crop_imgs(img):
    """
    按照图片的特点,进行切割,这个要根据具体的验证码来进行工作.
    :param img:
    :return:
    """
    for i in range(4):
        x = 8 + i * 23 
        y = 8
        child_img = img.crop((x, y, x + 23, y + 23))
        img_name = os.path.splitext(img)[0] + '_'+str(i) + '.bmp'
        img_name = Path(img_name).as_posix()
        child_img.save(img_name)

``` 

## 4、人工识别
这个步骤没啥好说的，就是将切割好的图片进行分类，前期自己调试的时候不需要太多，每个类型大概十来个就可以。
![flag](/image/falg.png)

## 5、获取字符特征
这个步骤是整个流程的关键，这取决于模型是否能够正确的识别。里面的逻辑依旧和验证码的大小有关，需要根据自己调试的图片进行修改。
``` code
def get_feature(img):
    """
    获取指定图片的特征值,
    1. 按照每排的像素点,高度为23,则有23个维度,然后为23列,总共23个维度
    :param img_path:
    :return:一个维度为23（高度）的列表
    """
    width, height = img.size
    pixel_cnt_list = []
    for y in range(height):
        pix_cnt_x = 0
        for x in range(width):
            if img.getpixel((x, y)) == 0:  # 黑色点
                pix_cnt_x += 1

        pixel_cnt_list.append(pix_cnt_x)

    for x in range(width):
        pix_cnt_y = 0
        for y in range(height):
            if img.getpixel((x, y)) == 0:  # 黑色点
                pix_cnt_y += 1

        pixel_cnt_list.append(pix_cnt_y)

    return pixel_cnt_list
``` 

## 6、生成libsvm格式数据文件
在获取到图片的特征后，需要将列表转化为libsvm可以识别的格式文件，格式文件和libsvm包的安装可以查看这位大佬整理的文章。[点这](https://www.cnblogs.com/Finley/p/5329417.html)
``` 代码
def libformat(name, flag, list):
    with open(name, 'a') as f:
        for i in range(len(list)):
            if i != 0:
                date = f'{i + 1}:{list[i]} '
            else:
                date = f'{ord(flag)} {i + 1}:{list[i]} '
            f.write(date)
            f.flush()
        f.write('\n')
        f.close()
``` 

## 7、模型训练
将上面的生成的libsvm格式文件通过libsvm生成模型
``` 代码
def get_model(modeldate):
    y, x = svm_read_problem(modeldate)
    model = svm_train(y, x)
    svm_save_model('model_file', model)
``` 

## 8、测试识别
最激动人心的时刻到了，识别单个验证码结果，在模型数量比较少的情况下，识别的正确率可能比较低，模型数量上去后，就可以达到100%。
``` 代码
def test_model(self):
    """
        return: 识别结果
    """
    model = svm_load_model(model_file)
    yt, xt = svm_read_problem(test_date)
    p_label, p_acc, p_val = svm_predict(yt, xt, model)  # p_label即为识别的结果
    result = ''
    for item in p_label:
        result = result + chr(int(item))
    print(result)
``` 
之后就是重复增加模型，提高验证码的识别率。
最后，感谢大家阅读这篇文章。其次代码中还有好多需要改进的地方，再者本人初次编写博客，存在哪些问题，恳请各位大佬指出，欢迎各位大佬评论留言。

